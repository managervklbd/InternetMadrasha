generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String           @id @default(cuid())
  email           String           @unique
  password        String?
  role            Role             @default(STUDENT)
  status          AccountStatus    @default(INVITED)
  invitationToken String?          @unique
  resetToken      String?          @unique
  resetTokenExpiry DateTime?
  lastLogin       DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  auditLogs       AdminActionLog[]
  studentProfile  StudentProfile?
  teacherProfile  TeacherProfile?
}

model StudentProfile {
  id                  String                @id @default(cuid())
  userId              String                @unique
  studentID           String                @unique
  fullName            String
  gender              Gender
  mode                StudentMode           @default(OFFLINE)
  residency           Residency             @default(LOCAL)
  country             String?
  phoneNumber         String?
  whatsappNumber      String?
  photoUrl            String?
  activeStatus        Boolean               @default(true)
  departmentId        String?
  feeTier             FeeTier               @default(GENERAL)
  attendance          Attendance[]
  enrollments         Enrollment[]
  homeworkSubmissions HomeworkSubmission[]
  liveClassAttendance LiveClassAttendance[]
  marks               Mark[]
  invoices            MonthlyInvoice[]
  planHistory         StudentPlanHistory[]
  department          Department?           @relation(fields: [departmentId], references: [id])
  user                User                  @relation(fields: [userId], references: [id])

  @@index([activeStatus])
  @@index([studentID])
}

model TeacherProfile {
  id              String             @id @default(cuid())
  userId          String             @unique
  fullName        String
  gender          Gender
  designation     String?            @default("Assistant Teacher")
  phone           String?
  address         String?
  joiningDate     DateTime?          @default(now())
  salary          Float?             @default(0)
  paymentMethod   PaymentMethod?     @default(CASH)
  bankAccountNumber String?
  mobileBankingNumber String?
  nid             String?
  specialization  String?
  activeStatus    Boolean            @default(true)
  homeworks       Homework[]
  liveClasses     MonthlyLiveClass[]
  payments        TeacherPayment[]
  user            User               @relation(fields: [userId], references: [id])
  assignedBatches Batch[]            @relation("TeacherBatches")
}

model TeacherPayment {
  id            String        @id @default(cuid())
  teacherId     String
  month         Int
  year          Int
  amount        Float
  paymentDate   DateTime      @default(now())
  status        PaymentStatus @default(PAID) // Reusing PaymentStatus or creating new? Using InvoiceStatus alias or string? Let's use string or new enum.
  method        PaymentMethod
  transactionId String?
  note          String?
  teacher       TeacherProfile @relation(fields: [teacherId], references: [id])
}

enum PaymentMethod {
  CASH
  BANK
  MOBILE_BANKING
}

enum PaymentStatus {
  PAID
  PENDING
  FAILED
}

model Course {
  id             String       @id @default(cuid())
  name           String       @unique
  code           String?
  admissionFee   Float?
  durationMonths Int?
  monthlyFee     Float?
  sadkaFee       Float?
  monthlyFeeOffline Float?
  sadkaFeeOffline   Float?
  admissionFeeOffline Float?
  departments    Department[]
}

model Department {
  id           String           @id @default(cuid())
  name         String
  code         String?
  courseId     String
  admissionFee Float?
  monthlyFee   Float?
  sadkaFee     Float?
  monthlyFeeOffline Float?
  sadkaFeeOffline   Float?
  admissionFeeOffline Float?
  batches      Batch[]
  course       Course           @relation(fields: [courseId], references: [id])
  students     StudentProfile[]
  subjects     Subject[]
}

model Subject {
  id            String         @id @default(cuid())
  name          String
  departmentId  String
  batchSubjects BatchSubject[]
  department    Department     @relation(fields: [departmentId], references: [id])
}

model Batch {
  id            String             @id @default(cuid())
  name          String
  type          BatchType          @default(MONTHLY)
  departmentId  String
  allowedGender Gender
  allowedMode   StudentMode        @default(OFFLINE)
  startDate     DateTime?
  endDate       DateTime?
  active        Boolean            @default(true)
  admissionFee  Float?
  monthlyFee    Float?
  sadkaFee      Float?
  monthlyFeeOffline Float?
  sadkaFeeOffline   Float?
  admissionFeeOffline Float?
  department    Department         @relation(fields: [departmentId], references: [id])
  batchSubjects BatchSubject[]
  sessions      ClassSession[]
  enrollments   Enrollment[]
  homeworks     Homework[]
  liveClasses   MonthlyLiveClass[]
  teachers      TeacherProfile[]   @relation("TeacherBatches")
}

model BatchSubject {
  id        String  @id @default(cuid())
  batchId   String
  subjectId String
  batch     Batch   @relation(fields: [batchId], references: [id])
  subject   Subject @relation(fields: [subjectId], references: [id])

  @@unique([batchId, subjectId])
}

model SessionTemplate {
  id        String @id @default(cuid())
  name      String
  startTime String
  endTime   String
}

model ClassSession {
  id         String       @id @default(cuid())
  batchId    String
  date       DateTime
  startTime  DateTime
  endTime    DateTime
  attendance Attendance[]
  batch      Batch        @relation(fields: [batchId], references: [id])
}

model Enrollment {
  id        String         @id @default(cuid())
  studentId String
  batchId   String
  joinedAt  DateTime       @default(now())
  batch     Batch          @relation(fields: [batchId], references: [id])
  student   StudentProfile @relation(fields: [studentId], references: [id])

  @@unique([studentId, batchId])
}

model Attendance {
  id             String           @id @default(cuid())
  studentId      String
  classSessionId String
  mode           StudentMode
  status         AttendanceStatus @default(PRESENT)
  joinTime       DateTime?
  leaveTime      DateTime?
  classSession   ClassSession     @relation(fields: [classSessionId], references: [id])
  student        StudentProfile   @relation(fields: [studentId], references: [id])

  @@unique([studentId, classSessionId])
}

model Plan {
  id          String               @id @default(cuid())
  name        String               @unique
  monthlyFee  Float
  description String?
  invoices    MonthlyInvoice[]
  history     StudentPlanHistory[]
}

model StudentPlanHistory {
  id        String         @id @default(cuid())
  studentId String
  planId    String
  startDate DateTime       @default(now())
  endDate   DateTime?
  plan      Plan           @relation(fields: [planId], references: [id])
  student   StudentProfile @relation(fields: [studentId], references: [id])
}

model MonthlyInvoice {
  id            String                  @id @default(cuid())
  studentId     String
  planId        String?
  month         Int
  year          Int
  amount        Float
  status        InvoiceStatus           @default(UNPAID)
  dueDate       DateTime
  issuedAt      DateTime                @default(now())
  ledgerEntries LedgerTransaction[]
  plan          Plan?                   @relation(fields: [planId], references: [id])
  student       StudentProfile          @relation(fields: [studentId], references: [id])
  transactions  SSLCommerzTransaction[]

  @@unique([studentId, month, year])
}

model SSLCommerzTransaction {
  id          String         @id @default(cuid())
  invoiceId   String
  storeId     String
  tranId      String         @unique
  valId       String?        @unique
  amount      Float
  currency    String         @default("BDT")
  tranDate    DateTime
  cardType    String?
  status      String
  bankTranId  String?
  rawResponse Json?
  invoice     MonthlyInvoice @relation(fields: [invoiceId], references: [id])
}

model LedgerTransaction {
  id              String          @id @default(cuid())
  fundType        FundType
  amount          Float
  dr_cr           String
  description     String?
  invoiceId       String?
  transactionDate DateTime        @default(now())
  referenceId     String?
  invoice         MonthlyInvoice? @relation(fields: [invoiceId], references: [id])
}

model Homework {
  id          String               @id @default(cuid())
  title       String
  description String
  batchId     String
  teacherId   String
  deadline    DateTime
  attachments String[]
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  batch       Batch                @relation(fields: [batchId], references: [id])
  teacher     TeacherProfile       @relation(fields: [teacherId], references: [id])
  submissions HomeworkSubmission[]
}

model HomeworkSubmission {
  id          String         @id @default(cuid())
  homeworkId  String
  studentId   String
  content     String?
  fileUrls    String[]
  submittedAt DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  grade       String?
  feedback    String?
  homework    Homework       @relation(fields: [homeworkId], references: [id])
  student     StudentProfile @relation(fields: [studentId], references: [id])
}

model Assessment {
  id         String   @id @default(cuid())
  name       String
  date       DateTime
  totalMarks Float
  marks      Mark[]
}

model Mark {
  id           String         @id @default(cuid())
  assessmentId String
  studentId    String
  subjectId    String
  obtainedMark Float
  comments     String?
  assessment   Assessment     @relation(fields: [assessmentId], references: [id])
  student      StudentProfile @relation(fields: [studentId], references: [id])
}

model ResultPublishLog {
  id           String   @id @default(cuid())
  batchId      String
  semesterName String
  publishedBy  String
  publishedAt  DateTime @default(now())
}

model SiteSettings {
  id             Int     @id @default(1)
  madrasaName    String
  madrasaAddress String?
  madrasaLogo    String?
  contactEmail   String?
  contactPhone   String?
  siteActive     Boolean @default(true)
  smtpHost       String?
  smtpPass       String?
  smtpPort       Int?
  smtpSecure     Boolean @default(false)
  smtpUser       String?
  sslIsSandbox   Boolean @default(true)
  sslStoreId     String?
  sslStorePass   String?
}

model AdminActionLog {
  id          String   @id @default(cuid())
  adminId     String
  action      String
  targetModel String
  targetId    String
  details     Json?
  ipAddress   String?
  createdAt   DateTime @default(now())
  admin       User     @relation(fields: [adminId], references: [id])
}

model MonthlyLiveClass {
  id          String                @id @default(cuid())
  title       String
  month       Int
  year        Int
  gender      Gender
  studentMode StudentMode           @default(ONLINE)
  teacherId   String
  batchId     String
  sessionKeys String[]              @default([])
  sessions    LiveClassSession[]
  liveLink    String
  active      Boolean               @default(true)
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  attendance  LiveClassAttendance[]
  batch       Batch                 @relation(fields: [batchId], references: [id])
  teacher     TeacherProfile        @relation(fields: [teacherId], references: [id])

  @@index([month, year, gender, active])
}

model LiveClassSessionConfig {
  id        String   @id @default(cuid())
  key       String   @unique
  label     String
  startTime String
  endTime   String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LiveClassAttendance {
  id          String           @id @default(cuid())
  studentId   String
  liveClassId String
  session     LiveClassSession @default(MORNING) // Keeping this for backward compatibility or make optional? It was required.
  sessionKey  String?          // For dynamic sessions
  sessionName String?          // Snapshot of the session label
  date        DateTime         @default(now())
  joinTime    DateTime         @default(now())
  liveClass   MonthlyLiveClass @relation(fields: [liveClassId], references: [id])
  student     StudentProfile   @relation(fields: [studentId], references: [id])

  @@index([studentId, date])
}

enum Role {
  ADMIN
  TEACHER
  STUDENT
}

enum AccountStatus {
  INVITED
  ACTIVE
  DISABLED
}

enum Gender {
  MALE
  FEMALE
}

enum StudentMode {
  ONLINE
  OFFLINE
}

enum Residency {
  LOCAL
  PROBASHI
}

enum BatchType {
  SEMESTER
  MONTHLY
}

enum FundType {
  ADMISSION
  MONTHLY
  DONATION
  DANA_COMMITTEE
}

enum InvoiceStatus {
  PAID
  UNPAID
  PARTIAL
  VOID
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  EXCUSED
}

enum LiveClassSession {
  MORNING
  NOON
  NIGHT
}

enum FeeTier {
  GENERAL
  SADKA
}

model Donor {
  id          String     @id @default(cuid())
  name        String
  phone       String?
  email       String?
  address     String?
  
  // New fields for Committee/Monthly support
  committee   String?    // e.g. "313 Badri Committee"
  type        String?    @default("GENERAL") // MONTHLY, GENERAL
  fixedAmount Float?     @default(0)
  notes       String?

  donations   Donation[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
}

model CommitteeMember {
  // Keeping this for now, but might migrate to Donor with type=COMMITTEE if user prefers single table
  // But user said "Committee... is one, Donor... is another". 
  // Ideally, Committee Members ARE Donors who pay monthly. 
  // Let's keep this model if it's used for literal board members, 
  // but the screenshot shown "Add Donor" includes "Committee Name".
  // This implies the "Donor" entity creates the link.
  id                 String     @id @default(cuid())
  name               String
  phone              String?
  email              String?
  role               String     @default("Member")
  active             Boolean    @default(true)
  collectedDonations Donation[]
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt
}

model Donation {
  id            String          @id @default(cuid())
  amount        Float
  purpose       DonationPurpose @default(DONATION)
  paymentMethod PaymentMethod   @default(CASH)
  transactionId String?
  date          DateTime        @default(now())
  receiptNo     String?         @unique
  notes         String?
  
  donorId       String?
  donor         Donor?          @relation(fields: [donorId], references: [id])
  
  collectedById String?
  collectedBy   CommitteeMember? @relation(fields: [collectedById], references: [id])
  
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
}

enum DonationPurpose {
  ZAKAT
  SADAQAH
  NAFL
  DONATION
  LILLAH_BOARDING
  CONSTRUCTION
  OTHER
}
